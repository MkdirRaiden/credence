generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum RedemptionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum OtpChannel {
  SMS
  EMAIL
}

enum CreditEvent {
  ISSUE
  REVOKE
  REFUND
  EXPIRE
}

enum IdempotencyScope {
  API
  JOB
}

enum IdempotencyStatus {
  STARTED
  SUCCEEDED
  FAILED
}

model IdempotencyRecord {
  // Core fields
  id             String            @id @default(uuid())
  scope          IdempotencyScope
  idempotencyKey String
  status         IdempotencyStatus @default(STARTED)
  // Optional fields for additional safety & debugging
  fingerprint    String?
  responseHash   String?
  lockedAt       DateTime?
  expiresAt      DateTime?
  // Timestamps
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Enforce uniqueness of (scope, idempotencyKey)
  @@unique([idempotencyKey], name: "uniq_idempotency_key")
  @@index([updatedAt])
}

model CreditLedger {
  // Core fields
  id                   String              @id @default(uuid())
  user                 User                @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  userId               String
  amount               Int
  event                CreditEvent
  // Self-relation for compensations/expirations referencing an original entry
  sourceLedgerId       String?
  sourceLedger         CreditLedger?       @relation("SourceLedger", fields: [sourceLedgerId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  compensations        CreditLedger[]      @relation("SourceLedger")
  // Optional origin from a referral redemption (bidirectional relation)
  referralRedemptionId String?
  referralRedemption   ReferralRedemption? @relation("RedemptionLedger", fields: [referralRedemptionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  // Domain-level idempotency boundary
  operationId          String?
  metadata             Json?
  // Optional expiration for issued credits
  expiresAt            DateTime?
  createdAt            DateTime            @default(now())

  // Enforce per-user uniqueness of a domain operation
  @@unique([userId, operationId], name: "uniq_user_operation")
  // Indexes for efficient queries
  @@index([userId, createdAt])
  @@index([expiresAt])
  @@index([referralRedemptionId])
}

model OtpCode {
  // Core fields
  id         String     @id @default(uuid())
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId     String
  channel    OtpChannel
  // Store only hash of OTP
  codeHash   String
  attempts   Int        @default(0)
  expiresAt  DateTime
  consumedAt DateTime?
  // Timestamps
  createdAt  DateTime   @default(now())

  // Indexes for efficient lookups and cleanup
  @@index([userId, expiresAt])
  @@index([expiresAt])
}

model ReferralCode {
  // Core fields
  id                     String               @id @default(uuid())
  owner                  User                 @relation(fields: [ownerUserId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  ownerUserId            String
  code                   String               @unique
  active                 Boolean              @default(true)
  // Optional fields for advanced features
  startsAt               DateTime?
  endsAt                 DateTime?
  maxRedemptionsPerMonth Int?
  // Timestamps
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
  // Back-reference to all redemptions of this code
  redemptions            ReferralRedemption[]

  // Indexes for efficient queries
  @@index([ownerUserId])
  @@index([active, startsAt, endsAt])
}

model ReferralRedemption {
  // Core fields
  id             String           @id @default(uuid())
  referrer       User             @relation("Referrer", fields: [referrerId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  referrerId     String
  referee        User             @relation("Referee", fields: [refereeId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  refereeId      String
  referralCode   ReferralCode     @relation(fields: [referralCodeId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  referralCodeId String
  status         RedemptionStatus @default(PENDING)
  // Optional admin fields for approved/rejected redemptions
  reason         String?
  idempotencyKey String?
  // Timestamps
  createdAt      DateTime         @default(now())
  decidedAt      DateTime?
  // Back-reference to all ledger entries created from this redemption
  ledgerEntries  CreditLedger[]   @relation("RedemptionLedger")

  // Optional idempotency scoping to referee if you generate per-referee keys (uncomment if desired)
  // @@unique([refereeId, idempotencyKey])
  // Each referee can redeem a specific code only once
  @@unique([referralCodeId, refereeId], name: "uniq_code_referee")
  // Indexes for efficient queries
  @@index([referrerId, createdAt])
  @@index([refereeId, createdAt])
}

model User {
  // Core fields
  id                    String               @id @default(uuid())
  email                 String               @unique
  phone                 String?              @unique
  passwordHash          String?
  role                  UserRole             @default(USER)
  // Self-referral graph
  referredById          String?
  referredBy            User?                @relation("Referrals", fields: [referredById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  referrals             User[]               @relation("Referrals")
  // Redemptions
  redemptionsAsReferrer ReferralRedemption[] @relation("Referrer")
  redemptionsAsReferee  ReferralRedemption[] @relation("Referee")
  // Referral codes owned by this user
  referralCodes         ReferralCode[]
  // OTPs
  otps                  OtpCode[]
  // Ledger
  credits               CreditLedger[]
  // Timestamps
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
}
